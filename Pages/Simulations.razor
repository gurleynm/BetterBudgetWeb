@page "/simulations"
@using BetterBudgetWeb.Data
@using BetterBudgetWeb.MainMenuItems
@using BetterBudgetWeb.MainMenuItems.Chart
@using BetterBudgetWeb.Repo
@using BetterBudgetWeb.Runner
@using BetterBudgetWeb.Simulation
@using System.Data;
@inject IJSRuntime JSRuntime

<style>
    option {
        color: black;
    }

    select {
        color: black;
    }

    input {
        color: black;
    }

    button {
        color: black;
    }
</style>

<PageTitle>Simulations</PageTitle>
<div style="display:flex;justify-content:space-around">
    @if (!(DateTime.Now.Month == Month && DateTime.Now.Year == Year))
    {
        <button style="align-self:last baseline" @onclick=Prev>&lt;&lt;</button>
    }
    else
    {
        <br />
    }
    <h1 style="text-align:center">Month of: <i>@MonthYear</i></h1>
    <button style="align-self:last baseline" @onclick=Next>&gt;&gt;</button>
</div>

<div style="display:flex;justify-content:space-around">
    <div style='display:@(mobile ? "inline-block" : "flex");justify-content:space-around'>
        <br />
        <br />
        <label style="float:left;margin-right:1vw;">@(Constants.Person1 + ":")</label>
        <div style="display:table">
            <input style="align-self:flex-end;display:table-cell" type="text" placeholder=@(Constants.Person1 + " Expected Income") @onkeydown="@Enter" @bind=ExpectedIncome1Str @oninput="@(async (ui) => { ExpectedIncome1Str = (string) ui.Value;})">
            <br />
            <br />
            <select class="custom-select" style="margin-right:1vw;" @bind="PaidIntoPerson1" title="Where You Get Paid ">
                <option value="@string.Empty" selected disabled="disabled">(Choose Where You Get Paid)</option>
                @if (Balances != null)
                {
                    @foreach (var pay in Balances.Where(b => b.Person == Constants.Person1 && !b.BalanceType.Contains("Loan")))
                    {
                        <option value="@pay.Name">@pay.Name</option>
                    }
                }
            </select>
            <br />
            <br />
            <div style="display:flex;justify-content:space-evenly;flex-direction:row;">
                <label>Set for All Months:</label>
                <input type="checkbox" @bind-value=@AllMonthsPerson1 />
            </div>
        </div>
        <br />
        <br />
        <label style="float:left;margin-right:1vw;">@(Constants.Person2 + ":")</label>
        <div style="display:table">
            <input style="align-self:flex-end;display:table-cell" type="text" placeholder=@(Constants.Person2 + " Expected Income") @onkeydown="@Enter" @bind=ExpectedIncome2Str @oninput="@(async (ui) => { ExpectedIncome2Str = (string) ui.Value;})">
            <br />
            <br />
            <select class="custom-select" style="margin-right:1vw;" @bind="PaidIntoPerson2" title="Where You Get Paid ">
                <option value="@string.Empty" selected disabled="disabled">(Choose Where You Get Paid)</option>
                @if (Balances != null)
                {
                    @foreach (var pay in Balances.Where(b => b.Person == Constants.Person2 && !b.BalanceType.Contains("Loan")))
                    {
                        <option value="@pay.Name">@pay.Name</option>
                    }
                }
            </select>
            <br />
            <br />
            <div style="display:flex;justify-content:space-evenly;flex-direction:row;">
                <label>Set for All Months:</label>
                <input type="checkbox" @bind-value=@AllMonthsPerson2 />
            </div>
        </div>
        <br />
        <br />
        <div style="display:flex;justify-content:center">
            <button class="btn btn-primary" style="margin: auto" @onclick=GoGo>Enter</button>
        </div>
    </div>
</div>

<h1 style="text-align:center;color:@GoodOrBad(Person1NetWorth + Person2NetWorth)">TOTAL NET WORTH: @(Pretty(Person1NetWorth + Person2NetWorth))</h1>
<div>
    <h2 style="float:left;text-align:center">
        <span>@($"{Constants.Person1}'s Net Worth:")</span> <span style="color:@GoodOrBad(Person1NetWorth)">@(Pretty(Person1NetWorth))</span>
    </h2>

    <h2 style="float:right;text-align:center">
        <span>@($"{Constants.Person2}'s Net Worth:")</span> <span style="color:@GoodOrBad(Person2NetWorth)">@(Pretty(Person2NetWorth))</span>
    </h2>
</div>
<br />
<br />
@if (!mobile)
{
    <div style="display:flex;justify-content:center;flex-wrap:wrap;width:95vw;">
        @if (Balances != null)
        {
            @foreach (var balance in Balances.OrderByDescending(b => b.Value))
            {
                <BalanceBlock TheBalance="@balance" />
            }

        }
    </div>
    <br style="clear:both;" />

    <div style="display:flex;justify-content:start;margin-bottom:2vh">
        <div style="display:inline-block;margin-right:1vw;">
            <!-- Dynamic Costs -->
            <div style="width:40vw; margin-right:1vw;">
                <table>
                    <tr>
                        <th colspan="4" style="background-color:magenta;color:white;"><i>Dynamic Monthly Costs</i></th>
                    </tr>
                    <tr>
                        <th>
                            <span>Expense</span>
                            <br />
                            <span>(@Constants.Person1 @Constants.Person2)</span>
                        </th>
                        <th>Total Budget Amount</th>
                        <th>Left This Month</th>
                        <th style="padding:0 5px">Spend/Day</th>
                    </tr>
                    @foreach (var dci in SimulatedConstants.DynamicCostItems)
                    {
                        @if (dci.Name.Contains("EXAMPLE DATA"))
                        {
                            <tr>
                                <td style="padding:.5vw 1vw;"><i>@dci.Name</i></td>
                                <td>@Pretty(dci.Amount)</td>
                                <td>@Pretty(Month == DateTime.Now.Month ? dci.Left : dci.Amount)</td>
                                <td>@Pretty(Month == DateTime.Now.Month ? dci.Left/DaysLeft : dci.Amount/DaysLeft)</td>
                            </tr>
                        }
                        else
                        {
                            <tr>
                                <td style="padding:.5vw 1vw;">
                                    <span style="align-self:start">@dci.Name</span>
                                    <div style="padding:.5vw 1vw;display:flex;justify-content:end;text-align:start">
                                        @if (Balances != null)
                                        {
                                            <select @onchange=@((ChangeEventArgs e) => DynaChanged(e, dci.Name, 1))>
                                                @foreach (var bal in Balances.Where(b => b.Person == Constants.Person1).OrderBy(ba => ba.Name))
                                                {
                                                    @if (DynaMonthMap[dci.Name].Item1 == bal.Name)
                                                    {
                                                        <option selected style="background-color:@bal.HexColor;color:@bal.TextColor">@bal.Name</option>
                                                    }
                                                    else
                                                    {
                                                        <option style="background-color:@bal.HexColor;color:@bal.TextColor">@bal.Name</option>
                                                    }
                                                }
                                            </select>
                                            <select @onchange=@((ChangeEventArgs e) => DynaChanged(e, dci.Name, 2))>
                                                @foreach (var bal in Balances.Where(b => b.Person == Constants.Person2).OrderBy(ba => ba.Name))
                                                {
                                                    @if (DynaMonthMap[dci.Name].Item2 == bal.Name)
                                                    {
                                                        <option selected style="background-color:@bal.HexColor;color:@bal.TextColor">@bal.Name</option>
                                                    }
                                                    else
                                                    {
                                                        <option style="background-color:@bal.HexColor;color:@bal.TextColor">@bal.Name</option>
                                                    }
                                                }
                                            </select>
                                        }
                                    </div>
                                </td>
                                <td>@Pretty(dci.Amount)</td>
                                <td>@Pretty(Month == DateTime.Now.Month ? dci.Left : dci.Amount)</td>
                                <td>@Pretty(Month == DateTime.Now.Month ? dci.Left/DaysLeft : dci.Amount/DaysLeft)</td>
                            </tr>
                        }
                    }
                    <tr>
                        <td colspan="4">=</td>
                    </tr>
                    <tr>
                        <td><strong>Total</strong></td>
                        <td>@Pretty(SimulatedConstants.DynamicCostItems.Sum(d => d.Amount))</td>
                        <td>@Pretty(SimulatedConstants.DynamicCostItems.Sum(d => d.Amount))</td>
                        <td>@Pretty(SimulatedConstants.DynamicCostItems.Sum(d => d.Amount)/DaysLeft)</td>
                    </tr>
                </table>
            </div>

        </div>
        <!-- Set Monthly Costs Goals-->
        <div style="display:inline-block">
            <SimulatedSetMonthlyTable Trans=Transactions Month=Month Year=Year @bind-StaticMonthMap=StaticMonthMap BalanceChanged=BalanceChanged />
        </div>

        <div style="display:inline-block">
            <!-- Savings Goals-->
            <SimulatedSavingsGoalsTable Month=Month Year=Year />
            <!-- Ideal Emergency Fund-->
            <IdealEmergencyFund />
        </div>
    </div>
}
else
{
    <div style="display:flex;justify-content:center;flex-wrap:wrap;width:95vw;">
        @if (Balances != null)
        {
            @foreach (var balance in Balances.OrderByDescending(b => b.Value))
            {
                <BalanceBlock TheBalance="@balance" FontSize="5" />
            }

        }
    </div>
    <br />
    <!-- Dynamic Costs -->
    <div style="width:100%;">
        <table>
            <tr>
                <th colspan="4" style="background-color:magenta;font-size:3vw;color:white"><i>Dynamic Monthly Costs</i></th>
            </tr>
            <tr>
                <th style="font-size:3vw;">Expense</th>
                <th style="font-size:3vw;">Total Budget Amount</th>
                <th style="font-size:3vw;">Left This Month</th>
                <th style="font-size:3vw;padding:0 5px">Spend/Day</th>
            </tr>
            @foreach (var dci in SimulatedConstants.DynamicCostItems)
            {
                @if (dci.Name.Contains("EXAMPLE DATA"))
                {
                    <tr>
                        <td style="font-size:3vw;padding:.5vw 1vw;"><i>@dci.Name</i></td>
                        <td style="font-size:3vw;">@Pretty(dci.Amount)</td>
                        <td style="font-size:3vw;">@Pretty(Month == DateTime.Now.Month ? dci.Left : dci.Amount)</td>
                        <td style="font-size:3vw;">@Pretty(Month == DateTime.Now.Month ? dci.Left/DaysLeft : dci.Amount/DaysLeft)</td>
                    </tr>
                }
                else
                {
                    <tr>
                        <td style="font-size:3vw;padding:.5vw 1vw;">
                            <span style="align-self:start">@dci.Name</span>
                            <div style="padding:.5vw 1vw;display:flex;justify-content:end;text-align:start">
                                @if (Balances != null)
                                {
                                    <select @onchange=@((ChangeEventArgs e) => DynaChanged(e, dci.Name, 1))>
                                        @foreach (var bal in Balances.Where(b => b.Person == Constants.Person1).OrderBy(ba => ba.Name))
                                        {
                                            @if (DynaMonthMap[dci.Name].Item1 == bal.Name)
                                            {
                                                <option selected style="background-color:@bal.HexColor;color:@bal.TextColor">@bal.Name</option>
                                            }
                                            else
                                            {
                                                <option style="background-color:@bal.HexColor;color:@bal.TextColor">@bal.Name</option>
                                            }
                                        }
                                    </select>
                                    <select @onchange=@((ChangeEventArgs e) => DynaChanged(e, dci.Name, 2))>
                                        @foreach (var bal in Balances.Where(b => b.Person == Constants.Person2).OrderBy(ba => ba.Name))
                                        {
                                            @if (DynaMonthMap[dci.Name].Item2 == bal.Name)
                                            {
                                                <option selected style="background-color:@bal.HexColor;color:@bal.TextColor">@bal.Name</option>
                                            }
                                            else
                                            {
                                                <option style="background-color:@bal.HexColor;color:@bal.TextColor">@bal.Name</option>
                                            }
                                        }
                                    </select>
                                }
                            </div>
                        </td>
                        <td style="font-size:3vw;">@Pretty(dci.Amount)</td>
                        <td style="font-size:3vw;">@Pretty(Month == DateTime.Now.Month ? dci.Left : dci.Amount)</td>
                        <td style="font-size:3vw;">@Pretty(Month == DateTime.Now.Month ? dci.Left/DaysLeft : dci.Amount/DaysLeft)</td>
                    </tr>
                }
            }
            <tr>
                <td style="font-size:3vw;" colspan="4">=</td>
            </tr>
            <tr>
                <td style="font-size:3vw;"><strong>Total</strong></td>
                <td style="font-size:3vw;">@Pretty(SimulatedConstants.DynamicCostItems.Sum(d => d.Amount))</td>
                <td style="font-size:3vw;">@Pretty(SimulatedConstants.DynamicCostItems.Sum(d => d.Left))</td>
                <td style="font-size:3vw;">@Pretty(SimulatedConstants.DynamicCostItems.Sum(d => d.Left)/DaysLeft)</td>
            </tr>
        </table>
    </div>

    <br />

    <!-- Set Monthly Costs Goals-->
    <SimulatedSetMonthlyTable Trans=FilteredTransactions Month=Month Year=Year @bind-StaticMonthMap=StaticMonthMap BalanceChanged=BalanceChanged Mobile=mobile />

    <br style="clear:both" />
    <br />

    <!-- Savings Goals-->
    <SimulatedSavingsGoalsTable Month=Month Year=Year Mobile=mobile />

    <br />

    <!-- Ideal Emergency Fund-->
    <IdealEmergencyFund />

    <br />
    <br />
}

@code {
    private string PaidIntoPerson1 { get; set; }
    private string PaidIntoPerson2 { get; set; }

    private string Dynamic1BalancePrev;
    private string dynamic1Balance;
    private string Dynamic1Balance
    {
        get { return dynamic1Balance; }
        set
        {
            Dynamic1BalancePrev = "" + dynamic1Balance;
            dynamic1Balance = value;
        }
    }

    private string Dynamic2BalancePrev;
    private string dynamic2Balance;
    private string Dynamic2Balance
    {
        get { return dynamic2Balance; }
        set
        {
            Dynamic2BalancePrev = "" + dynamic1Balance;
            dynamic2Balance = value;
        }
    }


    private bool AllMonthsPerson1 { get; set; }
    private bool AllMonthsPerson2 { get; set; }

    private string[] Months = new string[] { "All", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };

    private DateTime StartDate => DateTime.Now;
    private DateTime EndDate => new DateTime(StartDate.Year,
                                             StartDate.Month,
                                             DateTime.DaysInMonth(StartDate.Year,
                                             StartDate.Month));
    private int DaysLeft => DateTime.DaysInMonth(Year, Month);

    // (balance-name, month, year) -> $-value
    private Dictionary<(string, int, int), double> Previous { get; set; } = new Dictionary<(string, int, int), double>();

    // (month, year) -> $-value
    private Dictionary<(int, int), double> PrevIncome1 { get; set; } = new Dictionary<(int, int), double>();
    private Dictionary<(int, int), double> PrevIncome2 { get; set; } = new Dictionary<(int, int), double>();

    // Monthly-Name -> (Person1-BalanceName, Person2-BalanceName)
    private Dictionary<string, (string, string)> StaticMonthMap { get; set; } = new Dictionary<string, (string, string)>();
    private Dictionary<string, (string, string)> DynaMonthMap { get; set; } = new Dictionary<string, (string, string)>();

    private Dictionary<(int, int), Dictionary<string, (string, string)>> PrevStaticMonthMap { get; set; } = new Dictionary<(int, int), Dictionary<string, (string, string)>>();
    private Dictionary<(int, int), Dictionary<string, (string, string)>> PrevDynaMonthMap { get; set; } = new Dictionary<(int, int), Dictionary<string, (string, string)>>();

    private List<SimulatedPrev> SimPrevs { get; set; } = new List<SimulatedPrev>();

    private List<Transaction> Transactions;
    private List<Transaction> FilteredTransactions;
    private List<Balance> Balances;
    private List<Security> Securities;
    private List<Monthly> Monthlies;
    private double Person1NetWorth => CalculateNetWorth(Constants.Person1);
    private double Person2NetWorth => CalculateNetWorth(Constants.Person2);

    private int Month { get; set; } = DateTime.Now.Month;
    private int Year { get; set; } = DateTime.Now.Year;

    private string ExpectedIncome1Str { get; set; }
    private string ExpectedIncome2Str { get; set; }
    private double PrevExpected1Income;
    private double PrevExpected2Income;
    private double Expected1Income;
    private double Expected2Income;

    private string MonthYear => (new DateTime(Year, Month, 1).ToString("MMMM") + " " + Year.ToString());

    private string ErrorMsg = string.Empty;
    private bool mobile;


    protected override async Task OnInitializedAsync()
    {
        mobile = await JSRuntime.InvokeAsync<bool>("isDevice");
        await JSRuntime.InvokeAsync<bool>("TurnOnScroll");
        CatchAll catchAll = await CatchAllRunner.Grab();
        Balances = catchAll.Balances;
        Transactions = catchAll.Transactions;
        FilteredTransactions = new List<Transaction>(Transactions);
        FilteredTransactions = FilteredTransactions.Where(t => t.MonthYear() == SimulatedConstants.MonthYear(Month, Year)).OrderByDescending(t => t.DateOfTransaction).ToList();
        SimulatedConstants.SetMonthlies(Month, Year);
        ErrorMsg = string.Empty;

        PaidIntoPerson1 = Balances.Where(b => (b.Person == Constants.Person1 || b.Person.ToUpper() == "JOINT") && !b.BalanceType.Contains("Loan")).ToList()[0].Name;
        PaidIntoPerson2 = Balances.Where(b => (b.Person == Constants.Person2 || b.Person.ToUpper() == "JOINT") && !b.BalanceType.Contains("Loan")).ToList()[0].Name;

        StaticMonthMap = new Dictionary<string, (string, string)>();
        DynaMonthMap = new Dictionary<string, (string, string)>();

        PrevStaticMonthMap = new Dictionary<(int, int), Dictionary<string, (string, string)>>();
        PrevDynaMonthMap = new Dictionary<(int, int), Dictionary<string, (string, string)>>();

        SimPrevs = await SimulatedPrevRepo.GetSimulatedPrevsAsync();


        foreach (var smc in SimulatedConstants.StaticMonthlyCosts)
        {
            StaticMonthMap.Add(smc.Name, new(Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person1).Name,
                                             Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person2).Name));
        }

        /*vvvvvvv  USE THESE TO HELP BUILD A DB TABLE vvvvvv*/
        //var staticMonthString = System.Text.Json.JsonSerializer.Serialize<Dictionary<string, (string, string)>>(StaticMonthMap);
        /*^^^^^^^  USE THESE TO HELP BUILD A DB TABLE ^^^^^^*/

        foreach (var dci in SimulatedConstants.DynamicCostItems)
        {
            DynaMonthMap.Add(dci.Name, new(Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person1).Name,
                                             Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person2).Name));
        }

        GetPreviousState();

        PrevDynaMonthMap[(Month, Year)] = new Dictionary<string, (string, string)>(DynaMonthMap);
        PrevStaticMonthMap[(Month, Year)] = new Dictionary<string, (string, string)>(StaticMonthMap);

        SubtractUnspent();

        StateHasChanged();
    }

    private async void Prev()
    {
        await SaveCurrentState();

        if (Month == 1)
        {
            Month = 12;
            Year--;
        }
        else
            Month--;

        FilteredTransactions = new List<Transaction>(Transactions);
        FilteredTransactions = FilteredTransactions.Where(t => t.MonthYear() == SimulatedConstants.MonthYear(Month, Year)).OrderByDescending(t => t.DateOfTransaction).ToList();

        // This now calls SimulatedConstants.SetMonthlies(Month, Year);
        UpdateBalancesPrev();

        StaticMonthMap = new Dictionary<string, (string, string)>(PrevStaticMonthMap[(Month, Year)]);
        DynaMonthMap = new Dictionary<string, (string, string)>(PrevDynaMonthMap[(Month, Year)]);


        StateHasChanged();
    }
    private async void Next()
    {
        PrevStaticMonthMap[(Month, Year)] = new Dictionary<string, (string, string)>(StaticMonthMap);
        PrevDynaMonthMap[(Month, Year)] = new Dictionary<string, (string, string)>(DynaMonthMap);

        Dictionary<string, string> tempStatic = new Dictionary<string, string>();
        Dictionary<string, string> tempDyna = new Dictionary<string, string>();

        foreach (var key in StaticMonthMap.Keys)
            tempStatic.Add(key, StaticMonthMap[key].Item1 + "~" + StaticMonthMap[key].Item2);

        foreach (var key in DynaMonthMap.Keys)
            tempDyna.Add(key, DynaMonthMap[key].Item1 + "~" + DynaMonthMap[key].Item2);

        var staticMonthString = System.Text.Json.JsonSerializer.Serialize<Dictionary<string, string>>(tempStatic);
        var dynaMonthString = System.Text.Json.JsonSerializer.Serialize<Dictionary<string, string>>(tempDyna);

        await SaveCurrentState();


        if (Month == 12)
        {
            Month = 1;
            Year++;
        }
        else
            Month++;

        FilteredTransactions = new List<Transaction>(Transactions);
        FilteredTransactions = FilteredTransactions.Where(t => t.MonthYear() == SimulatedConstants.MonthYear(Month, Year)).OrderByDescending(t => t.DateOfTransaction).ToList();

        SimulatedConstants.SetMonthlies(Month, Year);

        UpdateBalancesNext();

        StateHasChanged();
    }

    private void UpdateBalancesPrev()
    {
        if (PrevIncome1.ContainsKey((Month, Year)) && PrevIncome1[(Month, Year)] != 0)
        {
            ExpectedIncome1Str = PrevIncome1[(Month, Year)].ToString();
            Expected1Income = PrevIncome1[(Month, Year)];
        }
        else
        {
            ExpectedIncome1Str = "";
            Expected1Income = 0;
        }

        if (PrevIncome2.ContainsKey((Month, Year)) && PrevIncome2[(Month, Year)] != 0)
        {
            ExpectedIncome2Str = PrevIncome2[(Month, Year)].ToString();
            Expected2Income = PrevIncome2[(Month, Year)];
        }
        else
        {
            ExpectedIncome2Str = "";
            Expected2Income = 0;
        }

        int ForMonth;
        int ForYear;
        if (Month == 12)
        {
            ForMonth = 1;
            ForYear = Year + 1;
        }
        else
        {
            ForMonth = Month + 1;
            ForYear = Year;
        }

        var Person1Income = Balances.FirstOrDefault(bal => bal.Name == PaidIntoPerson1);
        var Person2Income = Balances.FirstOrDefault(bal => bal.Name == PaidIntoPerson2);

        var DesiredMonthlies = SimulatedConstants.GetNeededMonthlies(ForMonth, ForYear);

        foreach (var mon in DesiredMonthlies)
        {
            if (StaticMonthMap.ContainsKey(mon.Name))
            {
                var balance1 = Balances.FirstOrDefault(bal => bal.Name == StaticMonthMap[mon.Name].Item1);
                var balance2 = Balances.FirstOrDefault(bal => bal.Name == StaticMonthMap[mon.Name].Item2);

                if (balance1.BalanceType == "Loan")
                    balance1.Value -= mon.Person1Amount;
                else
                    balance1.Value += mon.Person1Amount;

                if (balance2.BalanceType == "Loan")
                    balance2.Value -= mon.Person2Amount;
                else
                    balance2.Value += mon.Person2Amount;
            }
            else if (DynaMonthMap.ContainsKey(mon.Name))
            {
                var balance1 = Balances.FirstOrDefault(bal => bal.Name == DynaMonthMap[mon.Name].Item1);
                var balance2 = Balances.FirstOrDefault(bal => bal.Name == DynaMonthMap[mon.Name].Item2);

                if (balance1.BalanceType == "Loan")
                    balance1.Value -= mon.Person1Amount;
                else
                    balance1.Value += mon.Person1Amount;

                if (balance2.BalanceType == "Loan")
                    balance2.Value -= mon.Person2Amount;
                else
                    balance2.Value += mon.Person2Amount;
            }
        }

        foreach (var balance in Balances)
        {
            if (Previous.ContainsKey((balance.Name, Month, Year)))
            {
                if (balance.BalanceType == "Loan")
                {
                    balance.Value = Previous[(balance.Name, Month, Year)];

                    if (balance.Person == Constants.Person1)
                        Person1Income.Value += balance.Value;

                    if (balance.Person == Constants.Person2)
                        Person2Income.Value += balance.Value;
                }
            }
        }

        SimulatedConstants.SetMonthlies(Month, Year);

        StaticMonthMap = new Dictionary<string, (string, string)>();
        DynaMonthMap = new Dictionary<string, (string, string)>();

        foreach (var smc in SimulatedConstants.StaticMonthlyCosts)
        {
            StaticMonthMap.Add(smc.Name, new(Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person1).Name,
                                             Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person2).Name));
        }


        foreach (var dci in SimulatedConstants.DynamicCostItems)
        {
            DynaMonthMap.Add(dci.Name, new(Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person1).Name,
                                             Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person2).Name));
        }

        Person1Income.Value -= PrevIncome1.ContainsKey((ForMonth, ForYear)) ? PrevIncome1[(ForMonth, ForYear)] : 0;
        Person2Income.Value -= PrevIncome2.ContainsKey((ForMonth, ForYear)) ? PrevIncome2[(ForMonth, ForYear)] : 0;
    }

    private void UpdateBalancesNext()
    {
        if (PrevIncome1.ContainsKey((Month, Year)) && PrevIncome1[(Month, Year)] != 0)
        {
            ExpectedIncome1Str = PrevIncome1[(Month, Year)].ToString();
            Expected1Income = PrevIncome1[(Month, Year)];
        }
        else
        {
            if (AllMonthsPerson1)
            {
                UpdateIncomeBalances();
            }
            else
            {
                ExpectedIncome1Str = "";
                Expected1Income = 0;
            }
        }

        if (PrevIncome2.ContainsKey((Month, Year)) && PrevIncome2[(Month, Year)] != 0)
        {
            ExpectedIncome2Str = PrevIncome2[(Month, Year)].ToString();
            Expected2Income = PrevIncome2[(Month, Year)];
        }
        else
        {
            if (AllMonthsPerson2)
            {
                UpdateIncomeBalances();
            }
            else
            {
                ExpectedIncome2Str = "";
                Expected2Income = 0;
            }
        }

        var Person1Income = Balances.FirstOrDefault(bal => bal.Name == PaidIntoPerson1);
        var Person2Income = Balances.FirstOrDefault(bal => bal.Name == PaidIntoPerson2);

        (int, int) prevMonth = Month == 1 ? new(12, Year - 1) : new(Month - 1, Year);

        foreach (var balance in Balances)
        {
            Previous[(balance.Name, prevMonth.Item1, prevMonth.Item2)] = balance.Value + 0; // The "+ 0" passes it by reference, not value

            if (balance.BalanceType == "Loan")
            {
                if (balance.Person == Constants.Person1)
                    Person1Income.Value -= balance.Value;

                if (balance.Person == Constants.Person2)
                    Person2Income.Value -= balance.Value;

                balance.Value = 0;
            }
        }

        var DesiredMonthlies = SimulatedConstants.GetNeededMonthlies(Month, Year);

        StaticMonthMap = new Dictionary<string, (string, string)>();
        DynaMonthMap = new Dictionary<string, (string, string)>();

        foreach (var smc in SimulatedConstants.StaticMonthlyCosts)
        {
            StaticMonthMap.Add(smc.Name, new(Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person1).Name,
                                             Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person2).Name));
        }


        foreach (var dci in SimulatedConstants.DynamicCostItems)
        {
            DynaMonthMap.Add(dci.Name, new(Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person1).Name,
                                             Balances.OrderBy(ba => ba.Name).FirstOrDefault(b => b.Person == Constants.Person2).Name));
        }

        GetPreviousState();

        foreach (var mon in DesiredMonthlies)
        {
            if (StaticMonthMap.ContainsKey(mon.Name))
            {
                var balance1 = Balances.FirstOrDefault(bal => bal.Name == StaticMonthMap[mon.Name].Item1);
                var balance2 = Balances.FirstOrDefault(bal => bal.Name == StaticMonthMap[mon.Name].Item2);

                if (balance1.BalanceType == "Loan")
                    balance1.Value += mon.Person1Amount;
                else
                    balance1.Value -= mon.Person1Amount;

                if (balance2.BalanceType == "Loan")
                    balance2.Value += mon.Person2Amount;
                else
                    balance2.Value -= mon.Person2Amount;
            }
            else if (DynaMonthMap.ContainsKey(mon.Name))
            {
                var balance1 = Balances.FirstOrDefault(bal => bal.Name == DynaMonthMap[mon.Name].Item1);
                var balance2 = Balances.FirstOrDefault(bal => bal.Name == DynaMonthMap[mon.Name].Item2);

                if (balance1.BalanceType == "Loan")
                    balance1.Value += mon.Person1Amount;
                else
                    balance1.Value -= mon.Person1Amount;

                if (balance2.BalanceType == "Loan")
                    balance2.Value += mon.Person2Amount;
                else
                    balance2.Value -= mon.Person2Amount;
            }
        }

        Person1Income.Value += PrevIncome1.ContainsKey((Month, Year)) && !AllMonthsPerson1 ? PrevIncome1[(Month, Year)] : 0;
        Person2Income.Value += PrevIncome2.ContainsKey((Month, Year)) && !AllMonthsPerson2 ? PrevIncome2[(Month, Year)] : 0;
    }

    private void UpdateIncomeBalances(bool prev = false)
    {

        DataTable dt = new DataTable();
        bool tp1;
        bool tp2;

        try
        {
            tp1 = double.TryParse(dt.Compute(ExpectedIncome1Str, "").ToString(), out Expected1Income);
        }
        catch (Exception e)
        {
            tp1 = false;
        }
        try
        {
            tp2 = double.TryParse(dt.Compute(ExpectedIncome2Str, "").ToString(), out Expected2Income);
        }
        catch (Exception e)
        {
            tp2 = false;
        }

        var Person1Income = Balances.FirstOrDefault(bal => bal.Name == PaidIntoPerson1);
        var Person2Income = Balances.FirstOrDefault(bal => bal.Name == PaidIntoPerson2);

        if (tp1)
        {
            if (PrevIncome1.ContainsKey((Month, Year)))
                Person1Income.Value -= PrevIncome1[(Month, Year)];

            Person1Income.Value += Expected1Income;
            PrevIncome1[(Month, Year)] = Expected1Income;
        }

        if (tp2)
        {
            if (PrevIncome2.ContainsKey((Month, Year)))
                Person2Income.Value -= PrevIncome2[(Month, Year)];

            Person2Income.Value += Expected2Income;
            PrevIncome2[(Month, Year)] = Expected2Income;
        }
    }

    private string GoodOrBad(double money)
    {
        return money <= 0 ? "red" : "forestgreen";
    }
    private string Pretty(double num)
    {
        return Constants.Pretty(num);
    }
    private double CalculateNetWorth(string person)
    {
        return IndexRunner.CalculateNetWorth(person, Balances);
    }

    private async void Enter(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            GoGo();
        }

    }

    private async Task SaveCurrentState()
    {
        // Save current state
        if (SimPrevs != null)
        {
            Dictionary<string, string> tempStatic = new Dictionary<string, string>();
            Dictionary<string, string> tempDyna = new Dictionary<string, string>();

            var StaticSimPrev = SimPrevs.FirstOrDefault(sp => sp.MonthType == "STATIC" && sp.Month == Months[Month] && sp.Year == Year);
            var DynamicSimPrev = SimPrevs.FirstOrDefault(sp => sp.MonthType == "DYNAMIC" && sp.Month == Months[Month] && sp.Year == Year);

            foreach (var key in StaticMonthMap.Keys)
                tempStatic.Add(key, StaticMonthMap[key].Item1 + "~" + StaticMonthMap[key].Item2);

            foreach (var key in DynaMonthMap.Keys)
                tempDyna.Add(key, DynaMonthMap[key].Item1 + "~" + DynaMonthMap[key].Item2);

            var staticMonthString = System.Text.Json.JsonSerializer.Serialize<Dictionary<string, string>>(tempStatic);
            var dynaMonthString = System.Text.Json.JsonSerializer.Serialize<Dictionary<string, string>>(tempDyna);

            if (StaticSimPrev != null)
            {
                StaticSimPrev.JSONPrev = staticMonthString;
                SimPrevs = await SimulatedPrevRepo.AddOrUpdateAsync(StaticSimPrev);
            }
            else
                SimPrevs = await SimulatedPrevRepo.AddOrUpdateAsync(new SimulatedPrev
                    {
                        MonthType = "STATIC",
                        Month = Months[Month],
                        Year = Year,
                        JSONPrev = staticMonthString
                    });

            if (DynamicSimPrev != null)
            {
                DynamicSimPrev.JSONPrev = dynaMonthString;
                SimPrevs = await SimulatedPrevRepo.AddOrUpdateAsync(DynamicSimPrev);
            }
            else
                SimPrevs = await SimulatedPrevRepo.AddOrUpdateAsync(new SimulatedPrev
                    {
                        MonthType = "DYNAMIC",
                        Month = Months[Month],
                        Year = Year,
                        JSONPrev = dynaMonthString
                    });
        }
    }

    private void GetPreviousState()
    {
        if (SimPrevs != null)
        {
            var StaticSimPrev = SimPrevs.FirstOrDefault(sp => sp.MonthType == "STATIC" && sp.Month == Months[Month] && Year == Year);
            var DynamicSimPrev = SimPrevs.FirstOrDefault(sp => sp.MonthType == "DYNAMIC" && sp.Month == Months[Month] && Year == Year);

            if (StaticSimPrev != null)
                UpdateSimPrev(ref StaticSimPrev, "STATIC");

            if (DynamicSimPrev != null)
                UpdateSimPrev(ref DynamicSimPrev, "DYNAMIC");
        }
    }

    private void GoGo()
    {
        UpdateIncomeBalances();
    }

    private void SubtractUnspent()
    {
        DynamicCostItem TheDCI;
        StaticMonthlyCost TheSMC;

        Dictionary<string, (double, double)> RealValues = new Dictionary<string, (double, double)>();

        double SMCDifference;
        double DCIDifference;

        double TotalForDS1;
        double TotalForDS2;

        foreach (Transaction t in FilteredTransactions)
        {
            TheDCI = SimulatedConstants.DynamicCostItems.FirstOrDefault(d => t.ExpenseType == d.Name);
            if (TheDCI != null)
            {
                /*
                Check if the Expense Type for the Dynamic Cost Item already exists.

                If yes, add current t.PersonXAmount values to each respective item
                Otherwise, add it.
                */
                if (RealValues.ContainsKey(t.ExpenseType))
                    RealValues[t.ExpenseType] = (RealValues[t.ExpenseType].Item1 + t.Person1Amount, RealValues[t.ExpenseType].Item2 + t.Person2Amount);
                else
                    RealValues[t.ExpenseType] = (t.Person1Amount, t.Person2Amount);
            }

            TheSMC = SimulatedConstants.StaticMonthlyCosts.FirstOrDefault(d => t.Name == d.Name);
            if (TheSMC != null)
            {
                /*
                Check if the Name for the Static Cost exists.

                If yes, add current t.PersonXAmount values.
                */

                RealValues[t.Name] = (t.Person1Amount, t.Person2Amount);
            }
        }

        foreach (var sm in SimulatedConstants.StaticMonthlyCosts)
        {
            var Balance1ToUpdate = Balances.FirstOrDefault(bal => bal.Name == StaticMonthMap[sm.Name].Item1);
            var Balance2ToUpdate = Balances.FirstOrDefault(bal => bal.Name == StaticMonthMap[sm.Name].Item2);
            int LoanMultiplier1 = Balance1ToUpdate.BalanceType == "Loan" ? -1 : 1;
            int LoanMultiplier2 = Balance2ToUpdate.BalanceType == "Loan" ? -1 : 1;

            if (RealValues.ContainsKey(sm.Name))
            {

                // If Person1 has 0 and they are expected to pay, use the expected (sm.Person1Amount) value
                // Otherwise, do nothing because the value has already been subtracted when the transaction was added
                if (RealValues[sm.Name].Item1 == 0 && sm.Person1Amount != 0)
                    Balance1ToUpdate.Value -= sm.Person1Amount * LoanMultiplier1;

                // If Person2 has 0 and they are expected to pay, use the expected (sm.Person2Amount) value
                // Otherwise, do nothing because the value has already been subtracted when the transaction was added
                if (RealValues[sm.Name].Item2 == 0 && sm.Person2Amount != 0)
                    Balance2ToUpdate.Value -= sm.Person2Amount * LoanMultiplier2;
            }
            else
            {
                Balance1ToUpdate.Value -= sm.Person1Amount * LoanMultiplier1;
                Balance2ToUpdate.Value -= sm.Person2Amount * LoanMultiplier2;
            }
        }
        foreach (var dc in SimulatedConstants.DynamicCostItems)
        {
            var Balance1ToUpdate = Balances.FirstOrDefault(bal => bal.Name == DynaMonthMap[dc.Name].Item1);
            var Balance2ToUpdate = Balances.FirstOrDefault(bal => bal.Name == DynaMonthMap[dc.Name].Item2);
            int LoanMultiplier1 = Balance1ToUpdate.BalanceType == "Loan" ? -1 : 1;
            int LoanMultiplier2 = Balance2ToUpdate.BalanceType == "Loan" ? -1 : 1;

            if (RealValues.ContainsKey(dc.Name))
            {
                // If Person1 is expected to spend more than they have spent, add current spending back and subtracted the
                // greater value
                // Otherwise, do nothing because the real values (which would be greater than projected) have already been
                // subtracted when the transactions were added

                if (RealValues[dc.Name].Item1 < dc.Person1Amount)
                {
                    Balance1ToUpdate.Value += RealValues[dc.Name].Item1 * LoanMultiplier1;
                    Balance1ToUpdate.Value -= dc.Person1Amount * LoanMultiplier1;
                }

                // If Person2 is expected to spend more than they have spent, add current spending back and subtracted the
                // greater value
                // Otherwise, do nothing because the real values (which would be greater than projected) have already been
                // subtracted when the transactions were added

                if (RealValues[dc.Name].Item2 < dc.Person2Amount)
                {
                    Balance2ToUpdate.Value += RealValues[dc.Name].Item2 * LoanMultiplier2;
                    Balance2ToUpdate.Value -= dc.Person2Amount * LoanMultiplier2;
                }
            }
            else
            {
                // If here, then no RealValue was found. Subtract the expected value fo the expense
                Balance1ToUpdate.Value -= dc.Person1Amount * LoanMultiplier1;
                Balance2ToUpdate.Value -= dc.Person2Amount * LoanMultiplier1 - 2;
            }
        }
    }

    private void UpdateSimPrev(ref SimulatedPrev tempSimPrev, string monthType)
    {
        var tempMonthly = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, string>>(tempSimPrev.JSONPrev);

        var holder = new Dictionary<string, (string, string)>();

        foreach (var key in tempMonthly.Keys)
        {
            var splitter = tempMonthly[key].Split("~");
            holder.Add(key, new(splitter[0], splitter[1]));
        }

        if (monthType == "STATIC")
        {
            foreach (var key in StaticMonthMap.Keys)
                if (!holder.ContainsKey(key))
                    holder[key] = StaticMonthMap[key];

            StaticMonthMap = holder;
        }
        else
        {
            foreach (var key in DynaMonthMap.Keys)
                if (!holder.ContainsKey(key))
                    holder[key] = DynaMonthMap[key];

            DynaMonthMap = holder;
        }
    }

    private void DynaChanged(ChangeEventArgs e, string dciName, int person)
    {
        if (person == 1)
        {
            BalanceChanged(DynaMonthMap[dciName], (e.Value.ToString(), DynaMonthMap[dciName].Item2), dciName);
            DynaMonthMap[dciName] = (e.Value.ToString(), DynaMonthMap[dciName].Item2);
        }
        else
        {
            BalanceChanged(DynaMonthMap[dciName], (DynaMonthMap[dciName].Item1, e.Value.ToString()), dciName);
            DynaMonthMap[dciName] = (DynaMonthMap[dciName].Item1, e.Value.ToString());
        }
    }

    private void BalanceChanged((string, string) oldItem, (string, string) newItem, string monthName)
    {
        var DesiredMonthlies = SimulatedConstants.GetNeededMonthlies(Month, Year);

        var oldBalance1 = Balances.FirstOrDefault(b => b.Name == oldItem.Item1);
        var oldBalance2 = Balances.FirstOrDefault(b => b.Name == oldItem.Item2);

        var newBalance1 = Balances.FirstOrDefault(b => b.Name == newItem.Item1);
        var newBalance2 = Balances.FirstOrDefault(b => b.Name == newItem.Item2);

        Monthly ChangedMonthly = DesiredMonthlies.FirstOrDefault(dm => dm.Name == monthName);

        if (oldBalance1.Name != newBalance1.Name)
        {
            oldBalance1.Value += oldBalance1.BalanceType == "Loan" ? -ChangedMonthly.Person1Amount : ChangedMonthly.Person1Amount;
            newBalance1.Value += newBalance1.BalanceType == "Loan" ? ChangedMonthly.Person1Amount : -ChangedMonthly.Person1Amount;
        }

        if (oldBalance2.Name != newBalance2.Name)
        {
            oldBalance2.Value += oldBalance2.BalanceType == "Loan" ? -ChangedMonthly.Person2Amount : ChangedMonthly.Person2Amount;
            newBalance2.Value += newBalance2.BalanceType == "Loan" ? ChangedMonthly.Person2Amount : -ChangedMonthly.Person2Amount;
        }
        StateHasChanged();
    }
}