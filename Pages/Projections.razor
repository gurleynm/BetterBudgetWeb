@page "/chart"
@using BetterBudgetWeb.Data
@using BetterBudgetWeb.Repo
@using BetterBudgetWeb.Runner
@inject HttpClient Http
@inject IJSRuntime JSRuntime

<PageTitle>Sankey Chart</PageTitle>
<style>
    option {
        color: black;
    }

    select {
        color: black;
    }

    input {
        color: black;
    }

    button {
        color: black;
    }
</style>

<div id="sankey_basic" style="width: 100%; height: 75vh;background-color:aliceblue;overflow-x:auto;overflow-y:auto;
        margin-bottom:5vh;margin-right:5vw;"></div>

<select class="custom-select" @bind="SelectedDownload" title="Pick a Download Timeframe ">
    <option value="@string.Empty" selected disabled="disabled">(Choose a download)</option>
    <option value="All">All</option>
    @foreach (var dt in FoundMonths)
    {
        <option value="@dt">@dt</option>
    }
</select>
@if (Levels != null && Levels.Count > 0)
{
    <select class="custom-select" @bind="SelectedLevel" title="Pick a Level ">
        <option value="@string.Empty" selected disabled="disabled">(Choose a level)</option>
        <option value="All">All</option>
        @foreach (var dt in Levels)
        {
            <option value="@dt">@dt</option>
        }
    </select>
}

<button class="btn btn-primary" style="margin: auto 5vw" @onclick=DrawChart>Enter</button>
@*
<table style="margin: auto 10vw; width:40vw; float:right">
    <tr>
        <th></th>
        <th>Total In</th>
        <th>Total Out</th>
        <th>Difference</th>
    </tr>
    <tr>
        <td>Thing</td>
        <td>Thing</td>
        <td>Thing</td>
        <td>Thing</td>
    </tr>
</table>
*@

@code {
    private string selectedDownload;
    private string SelectedDownload
    {
        get { return selectedDownload; }
        set
        {
            if (value == null || value == selectedDownload)
                return;

            List<Transaction> DesiredTransactions;

            selectedDownload = value;

            if (SelectedDownload != "All")
                DesiredTransactions = Constants.Transactions.Where(tr => tr.MonthYear() == SelectedDownload).OrderByDescending(t => t.DateOfTransaction).ToList();
            else
                DesiredTransactions = Constants.Transactions.OrderByDescending(t => t.DateOfTransaction).ToList();

            SelectedLevel = "All";

            Levels = new List<string>();

            string[] IgnoreThese = new string[] { "Debt", "Income", "Equity", "Envelope", "Transfer" };

            foreach (var dt in DesiredTransactions)
            {
                if (Levels.Contains(dt.ExpenseType) || IgnoreThese.Contains(dt.ExpenseType))
                    continue;

                Levels.Add(dt.ExpenseType);
            }
        }
    }
    private string SelectedLevel { get; set; }

    private List<string> FoundMonths => IndexRunner.GetMonths(Constants.Transactions);
    private List<string> Levels = new List<string>();
    private List<CashFlow> CashFlows = new List<CashFlow>();

    protected override Task OnInitializedAsync()
    {
        SelectedDownload = "All";
        DrawChart();
        return base.OnInitializedAsync();
    }

    public async void DrawChart()
    {
        if (string.IsNullOrEmpty(SelectedLevel))
            return;

        await JSRuntime.InvokeAsync<bool>("TurnOffScroll");
        List<Flow> objs = GetFlows(SelectedDownload);

        var json = System.Text.Json.JsonSerializer.Serialize(objs);
        await JSRuntime.InvokeAsync<object>("drawChart", json);
    }

    private List<Flow> GetFlows(string SelectedDownload)
    {
        List<Flow> TheFlows = new List<Flow>();
        List<Transaction> DesiredTransactions = new List<Transaction>();
        Dictionary<string, Transaction> DesiredTransactionsDict = new Dictionary<string, Transaction>();
        Dictionary<string, Transaction> DictIncome = new Dictionary<string, Transaction>();

        if (SelectedDownload != "All")
            DesiredTransactions = Constants.Transactions.Where(tr => tr.MonthYear() == SelectedDownload).OrderByDescending(t => t.DateOfTransaction).ToList();
        else
            DesiredTransactions = Constants.Transactions.OrderByDescending(t => t.DateOfTransaction).ToList();

        if (SelectedLevel != "All")
            DesiredTransactions = DesiredTransactions.Where(dt => dt.ExpenseType == SelectedLevel).ToList();

        string TKey;
        string[] IgnoreThese = new string[] { "Debt", "Equity", "Transfer", "Envelope" };

        foreach (var transact in DesiredTransactions)
        {
            if (IgnoreThese.Contains(transact.ExpenseType))
                continue;

            TKey = transact.Name;

            if (transact.ExpenseType == "Income")
            {
                if (DictIncome.ContainsKey(TKey))
                {
                    DictIncome[TKey].Person1Amount += transact.Person1Amount;
                    DictIncome[TKey].Person2Amount += transact.Person2Amount;
                }
                else
                {
                    DictIncome[TKey] = new Transaction(transact);
                }
                continue;
            }


            if (DesiredTransactionsDict.ContainsKey(TKey))
            {
                DesiredTransactionsDict[TKey].Person1Amount += transact.Person1Amount;
                DesiredTransactionsDict[TKey].Person2Amount += transact.Person2Amount;
            }
            else
            {
                DesiredTransactionsDict[TKey] = new Transaction(transact);
            }
        }

        Dictionary<string, Transaction> GeneralTransactions = new Dictionary<string, Transaction>();
        Transaction trans;
        var keys = DesiredTransactionsDict.Keys.ToArray();
        Array.Sort(keys);
        foreach (var key in keys)
        {
            if (DesiredTransactionsDict[key].TotalAmount < 0)
                continue;

            if (SelectedLevel != "All")
                TheFlows.Add(DesiredTransactionsDict[key].ToFlow());

            trans = DesiredTransactionsDict[key];

            if (trans.ExpenseType == "Income")
                continue;
            else if (trans.ExpenseType == "Envelope")
                TKey = trans.Name;
            else if (IgnoreThese.Contains(trans.ExpenseType) || trans.ExpenseType == "Income")
                continue;
            else
                TKey = trans.ExpenseType;

            if (GeneralTransactions.ContainsKey(TKey))
            {
                GeneralTransactions[TKey].Person1Amount += trans.Person1Amount;
                GeneralTransactions[TKey].Person2Amount += trans.Person2Amount;
            }
            else
            {
                if (trans.ExpenseType == "Envelope")
                    GeneralTransactions[TKey] = new Transaction
                        {
                            Person1Amount = trans.Person1Amount,
                            Person2Amount = trans.Person2Amount,
                            ExpenseType = trans.Name,
                            Name = trans.ExpenseType
                        };
                else
                    GeneralTransactions[TKey] = new Transaction(trans);
            }
        }

        if (SelectedLevel == "All")
        {
            foreach (var key in DictIncome.Keys)
                TheFlows.Add(DictIncome[key].ToFlow());

            foreach (var key in GeneralTransactions.Keys)
                TheFlows.Add(GeneralTransactions[key].ToFlow("GENERAL"));
        }

        return TheFlows;
    }

    public class CashFlow
    {
        public string Name { get; set; }
        public double In { get; set; }
        public double Out { get; set; }
        public CashFlow() {}
    }
}